vim9script

import autoload './autoload/keymaps.vim' as K

# Options {{{

g:mapleader = ' '
g:maplocalleader = '\'
g:qf_disable_statusline = true

syntax enable
filetype plugin on
filetype indent on

set autoindent
set autoread
set belloff=all
set breakindent
set confirm
set cursorline
set encoding=utf8
set expandtab
set fileformats=unix,dos # Use Unix as the standard file type
set hidden # A buffer becomes hidden when it is abandoned
set hlsearch
set ignorecase
set incsearch
set laststatus=2
set listchars=nbsp:+,space:·,tab:»\ ,trail:-
set mouse=
set nobackup
set noswapfile
set novisualbell
set nowritebackup
set number
set relativenumber
set ruler
set scrolloff=4
set shiftwidth=4
set shortmess=filnxtToOFWI
set showcmd
set showcmdloc=statusline
set showmatch
set showmode
set sidescrolloff=8
set signcolumn=yes
set smartcase
set smartindent
set smarttab
set softtabstop=4
set splitbelow
set splitright
set tabstop=4
set timeoutlen=500
set wildmenu
set wildmode=full
set wildoptions=fuzzy,pum,tagfile

# Theme
if has('termguicolors')
    set termguicolors
endif
colorscheme catppuccin

if &term =~ 'xterm\|tmux\|win'
    # INSERT mode
    &t_SI = "\<esc>[6 q"
    # REPLACE mode
    &t_SR = "\<esc>[4 q"
    # NORMAL mode
    &t_EI = "\<esc>[2 q"
endif

# GUI
if has('gui_running')
    set guifont=Maple\ Mono\ NF\ CN:h14
    set guioptions=
endif

const has_rg = executable('rg')
const has_fd = executable('fd')

# Grep
if has_rg
    set grepprg=rg\ --vimgrep\ -uu
    set grepformat^=%f:%l:%c:%m
endif

# File picker
set findfunc=Find
def Find(arg: string, _: any): list<string>
    if empty(filescache)
        if has_fd
            filescache = systemlist('fd --type f')
        else
            filescache = globpath('.', '**', 1, 1)
            filter(filescache, (_, v) => !isdirectory(v))
            map(filescache, (_, v) => fnamemodify(v, ':.'))
        endif
    endif
    return arg == '' ? filescache : matchfuzzy(filescache, arg)
enddef
var filescache = []
autocmd CmdlineEnter : filescache = []

# }}}

# Keymaps {{{

# Escape
inoremap jj <Esc>
tnoremap <Esc><Esc> <C-\><C-n>

# Add undo break-points
inoremap , ,<C-g>u
inoremap . .<C-g>u
inoremap ; ;<C-g>u

# Better inputs
noremap! ,, _
noremap! ,. &
noremap! ,/ *

# Better up/down
nnoremap <expr> j v:count == 0 ? 'gj' : 'j'
xnoremap <expr> j v:count == 0 ? 'gj' : 'j'
nnoremap <expr> k v:count == 0 ? 'gk' : 'k'
xnoremap <expr> k v:count == 0 ? 'gk' : 'k'

# Move
noremap gs ^
noremap gh 0
noremap gl $
noremap! <C-l> <Right>

# Better indenting
vnoremap < <gv
vnoremap > >gv

# Add space line
nnoremap [<Space> <Cmd>call <SID>K.AddBlank(1)<CR>
nnoremap ]<Space> <Cmd>call <SID>K.AddBlank(0)<CR>

# Yank and paste
noremap <Leader>y "+y
noremap <Leader>p "+p

# Clear highlight
nnoremap <Esc> <Cmd>noh<CR><Esc>

# Close
nnoremap <C-q> <Cmd>close<CR>
tnoremap <C-q> <Cmd>close<CR>
nnoremap <expr> q &buftype == '' ? 'q' : '<Cmd>close<CR>'

# Buffer
nnoremap [b <Cmd>bp<CR>
nnoremap ]b <Cmd>bn<CR>
nnoremap [B <Cmd>bfirst<CR>
nnoremap ]B <Cmd>blast<CR>
nnoremap <Leader>bb <Cmd>e #<CR>
nnoremap <Leader>bc <Cmd>bd<CR>
nnoremap <Leader>bo <Cmd>call <SID>K.CloseOtherBuffers()<CR>

# Quickfix
nnoremap [q <Cmd>cprevious<CR>
nnoremap ]q <Cmd>cnext<CR>
nnoremap [l <Cmd>lprevious<CR>
nnoremap ]l <Cmd>lnext<CR>

# Windows
map <Leader>w <C-w>

# Resize window
nnoremap <C-Up> <Cmd>resize +2<CR>
nnoremap <C-Down> <Cmd>resize -2<CR>
nnoremap <C-Left> <Cmd>vertical resize -2<CR>
nnoremap <C-Right> <Cmd>vertical resize +2<CR>

# Tabs
nnoremap [<Tab> <Cmd>tabprevious<CR>
nnoremap ]<Tab> <Cmd>tabnext<CR>
nnoremap <Leader><Tab>[ <Cmd>tabfirst<CR>
nnoremap <Leader><Tab>] <Cmd>tablast<CR>
nnoremap <Leader><Tab><Tab> <Cmd>tabnew<CR>
nnoremap <Leader><Tab>c <Cmd>tabclose<CR>
nnoremap <Leader><Tab>o <Cmd>tabonly<CR>

# }}}

# Autocmds {{{

if has('win32') || has('win64')
    autocmd GUIEnter * simalt ~x
endif

# }}}
